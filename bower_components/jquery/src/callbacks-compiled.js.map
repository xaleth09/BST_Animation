{"version":3,"sources":["callbacks.js"],"names":[],"mappings":"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","file":"callbacks-compiled.js","sourcesContent":["define( [\r\n\t\"./core\",\r\n\t\"./var/rnotwhite\"\r\n], function( jQuery, rnotwhite ) {\r\n\r\n// Convert String-formatted options into Object-formatted ones\r\nfunction createOptions( options ) {\r\n\tvar object = {};\r\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\r\n\t\tobject[ flag ] = true;\r\n\t} );\r\n\treturn object;\r\n}\r\n\r\n/*\r\n * Create a callback list using the following parameters:\r\n *\r\n *\toptions: an optional list of space-separated options that will change how\r\n *\t\t\tthe callback list behaves or a more traditional option object\r\n *\r\n * By default a callback list will act like an event callback list and can be\r\n * \"fired\" multiple times.\r\n *\r\n * Possible options:\r\n *\r\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\r\n *\r\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\r\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\r\n *\t\t\t\t\tvalues (like a Deferred)\r\n *\r\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\r\n *\r\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\r\n *\r\n */\r\njQuery.Callbacks = function( options ) {\r\n\r\n\t// Convert options from String-formatted to Object-formatted if needed\r\n\t// (we check in cache first)\r\n\toptions = typeof options === \"string\" ?\r\n\t\tcreateOptions( options ) :\r\n\t\tjQuery.extend( {}, options );\r\n\r\n\tvar // Flag to know if list is currently firing\r\n\t\tfiring,\r\n\r\n\t\t// Last fire value for non-forgettable lists\r\n\t\tmemory,\r\n\r\n\t\t// Flag to know if list was already fired\r\n\t\tfired,\r\n\r\n\t\t// Flag to prevent firing\r\n\t\tlocked,\r\n\r\n\t\t// Actual callback list\r\n\t\tlist = [],\r\n\r\n\t\t// Queue of execution data for repeatable lists\r\n\t\tqueue = [],\r\n\r\n\t\t// Index of currently firing callback (modified by add/remove as needed)\r\n\t\tfiringIndex = -1,\r\n\r\n\t\t// Fire callbacks\r\n\t\tfire = function() {\r\n\r\n\t\t\t// Enforce single-firing\r\n\t\t\tlocked = options.once;\r\n\r\n\t\t\t// Execute callbacks for all pending executions,\r\n\t\t\t// respecting firingIndex overrides and runtime changes\r\n\t\t\tfired = firing = true;\r\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\r\n\t\t\t\tmemory = queue.shift();\r\n\t\t\t\twhile ( ++firingIndex < list.length ) {\r\n\r\n\t\t\t\t\t// Run callback and check for early termination\r\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\r\n\t\t\t\t\t\toptions.stopOnFalse ) {\r\n\r\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\r\n\t\t\t\t\t\tfiringIndex = list.length;\r\n\t\t\t\t\t\tmemory = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Forget the data if we're done with it\r\n\t\t\tif ( !options.memory ) {\r\n\t\t\t\tmemory = false;\r\n\t\t\t}\r\n\r\n\t\t\tfiring = false;\r\n\r\n\t\t\t// Clean up if we're done firing for good\r\n\t\t\tif ( locked ) {\r\n\r\n\t\t\t\t// Keep an empty list if we have data for future add calls\r\n\t\t\t\tif ( memory ) {\r\n\t\t\t\t\tlist = [];\r\n\r\n\t\t\t\t// Otherwise, this object is spent\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlist = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Actual Callbacks object\r\n\t\tself = {\r\n\r\n\t\t\t// Add a callback or a collection of callbacks to the list\r\n\t\t\tadd: function() {\r\n\t\t\t\tif ( list ) {\r\n\r\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\r\n\t\t\t\t\tif ( memory && !firing ) {\r\n\t\t\t\t\t\tfiringIndex = list.length - 1;\r\n\t\t\t\t\t\tqueue.push( memory );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t( function add( args ) {\r\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\r\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\r\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\r\n\t\t\t\t\t\t\t\t\tlist.push( arg );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\r\n\r\n\t\t\t\t\t\t\t\t// Inspect recursively\r\n\t\t\t\t\t\t\t\tadd( arg );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\t} )( arguments );\r\n\r\n\t\t\t\t\tif ( memory && !firing ) {\r\n\t\t\t\t\t\tfire();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// Remove a callback from the list\r\n\t\t\tremove: function() {\r\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\r\n\t\t\t\t\tvar index;\r\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\r\n\t\t\t\t\t\tlist.splice( index, 1 );\r\n\r\n\t\t\t\t\t\t// Handle firing indexes\r\n\t\t\t\t\t\tif ( index <= firingIndex ) {\r\n\t\t\t\t\t\t\tfiringIndex--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// Check if a given callback is in the list.\r\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\r\n\t\t\thas: function( fn ) {\r\n\t\t\t\treturn fn ?\r\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\r\n\t\t\t\t\tlist.length > 0;\r\n\t\t\t},\r\n\r\n\t\t\t// Remove all callbacks from the list\r\n\t\t\tempty: function() {\r\n\t\t\t\tif ( list ) {\r\n\t\t\t\t\tlist = [];\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// Disable .fire and .add\r\n\t\t\t// Abort any current/pending executions\r\n\t\t\t// Clear all callbacks and values\r\n\t\t\tdisable: function() {\r\n\t\t\t\tlocked = queue = [];\r\n\t\t\t\tlist = memory = \"\";\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tdisabled: function() {\r\n\t\t\t\treturn !list;\r\n\t\t\t},\r\n\r\n\t\t\t// Disable .fire\r\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\r\n\t\t\t// Abort any pending executions\r\n\t\t\tlock: function() {\r\n\t\t\t\tlocked = queue = [];\r\n\t\t\t\tif ( !memory ) {\r\n\t\t\t\t\tlist = memory = \"\";\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tlocked: function() {\r\n\t\t\t\treturn !!locked;\r\n\t\t\t},\r\n\r\n\t\t\t// Call all callbacks with the given context and arguments\r\n\t\t\tfireWith: function( context, args ) {\r\n\t\t\t\tif ( !locked ) {\r\n\t\t\t\t\targs = args || [];\r\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\r\n\t\t\t\t\tqueue.push( args );\r\n\t\t\t\t\tif ( !firing ) {\r\n\t\t\t\t\t\tfire();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// Call all the callbacks with the given arguments\r\n\t\t\tfire: function() {\r\n\t\t\t\tself.fireWith( this, arguments );\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\t// To know if the callbacks have already been called at least once\r\n\t\t\tfired: function() {\r\n\t\t\t\treturn !!fired;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\treturn self;\r\n};\r\n\r\nreturn jQuery;\r\n} );\r\n"]}